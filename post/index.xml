<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MakieCrise</title>
    <link>https://makisecrise.github.io/post/</link>
    <description>Recent content in Posts on MakieCrise</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Jul 2024 21:06:12 +0800</lastBuildDate>
    <atom:link href="https://makisecrise.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于MyBaits</title>
      <link>https://makisecrise.github.io/post/%E5%85%B3%E4%BA%8Emybaits/</link>
      <pubDate>Wed, 17 Jul 2024 21:05:21 +0800</pubDate>
      <guid>https://makisecrise.github.io/post/%E5%85%B3%E4%BA%8Emybaits/</guid>
      <description>MyBaits工具对数据库操作效率的提升与对sql注入操作的预防 在不使用MyBaits一类数据库操作工具的情况下，程序员们编写对数据库操作的代码时，一般采用字符串拼接的形式来将用户的输入拼接到提前编写好的sql语句中。这种传统的操作方式不仅繁琐而且具有安全隐患，在这种不便的促进下，MyBaits一类的数据库操作简化工具应运而生。&#xA;原始版本的数据库操作示例如下：&#xA;///用户输入的参数 A String sql = &amp;#34;Delete fro&amp;#34; +&amp;#34;A&amp;#34;; ///或者用户输入的参数A,B String sql = &amp;#34;Select count(*) from 表名 where username =&amp;#34; + &amp;#34;A&amp;#34;+&amp;#34;and password=&amp;#34;+&amp;#34;B&amp;#34;; 这种情况下，用户可以输入一种组合后的字符串，导致原先设定好的sql语句失去效果甚至导致用户可以直接无视程序员的限制对数据库进行操作。 且这种预先写死的硬编码程序也会导致程序效率的降低，因为程序每一次运行到这几行代码都需要重新编译执行一次这些sql语句。 MyBaits工具则采用注解加传参的方式来提高效率且预防sql注入的产生。 以下是一个示例：&#xA;public interface Mapper{ @Delete(&amp;#34;Delete from 表名 where id = #{id}&amp;#34;) public void Delete(Integer id); } 作为一个抽象接口，在需要调用的时候使用IOC自动注入（@Autowired）来产生一个实例化的对象。 其中#{id}为MyBaits的传参格式，注解语句内可含有多个参数。&#xA;MyBaits解决了原始JDBC操作繁琐，且采用预编译的手段提高了数据库操作的性能与安全性。 传统sql语句的每次执行都需经历以下四步：&#xA;sql语法解析检查 优化sql语句 编译sql语句 执行sql语句 MyBaits在第三步的时候将编译好的sql语句存储在缓冲区，在下一次遇到sql语句执行操作的时候，优先查看缓冲区数据，若有符合的则直接使用，以此来提升效率。 缓冲区中的sql语句以一种预编译的方式存储，这种存储方式允许有代码缺失，在使用的时候传入的参数直接编码代入预编译sql中的缺省区域。 这种预编译的方式有效的减少的sql注入的发生。</description>
    </item>
    <item>
      <title>网络端口扫描与防御</title>
      <link>https://makisecrise.github.io/post/%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8E%E9%98%B2%E5%BE%A1/</link>
      <pubDate>Mon, 15 Jul 2024 16:12:33 +0800</pubDate>
      <guid>https://makisecrise.github.io/post/%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E4%B8%8E%E9%98%B2%E5%BE%A1/</guid>
      <description>网络程序与外部的通讯需要由TCP或者IP传输层的端口承载，换言之，每个端口都是一条通信信道，开放的端口会为外来的攻击行为提供漏洞。&#xA;以下是五种常见的端口扫描&#xA;TCP SYN扫描&#xA;TCP指传输协议，SYN代表同步传输。TCP SYN传输的过程如下： 主机发送向靶机某端口发送SYN包，靶机的回应有以下两种&#xA;靶机回复RST（Reset复位）包，代表靶机当前端口是关闭的。 靶机回复SYN/ACK包，目标主机接受后发送RST包表示建立连接。 TCP Connect 全连接扫描&#xA;主机向靶机某端口发送SYN包，靶机会有以下两种回复&#xA;靶机回复RST包，代表靶机当前端口是关闭的。 靶机回复SYN/ACK包，主机在收到回复后，发送ACK包，随后紧接着发送RST包代表成功建立连接。 TCP ACK确认扫描&#xA;主机向靶机发送SYN包，靶机会有以下两种回复&#xA;靶机回复RST包，表示端口未被防火墙过滤。 靶机不回复，表示端口被防火墙过滤。 注意这种扫描只能扫描出端口的过滤情况，无论靶机何种回复，都无法确认端口的开放情况。&#xA;TCP 秘密扫描&#xA;主机向靶机目标端口发送TCP FIN，Xmas tree（flag中的FIN URG PUSH被置为1），NULL（flags全为0）包三种之一。 靶机会有以下两种状态&#xA;不回复，表示靶机目标端口开放或被过滤。 靶机回复RST包，表示靶机目标端口关闭。 UDP 扫描 主机向靶机目标端口发送UDP包，靶机会有以下两种状态&#xA;靶机不回复，表示目标端口被过滤或开启。 靶机回复ICMP:portunreachable表示目标端口关闭。 常见的网络端口扫描防御大多数为开启防火墙，关闭ICMP应答与关闭不必要的端口。对于必须开放的端口可以进行端口伪装，也就是把默认的端口号更改来进行防御。&#xA;使用nmap工具可以对网段内的ip进行端口扫描，nmap的具体使用方式可以查看下方链接 Nmap使用教程图文教程（超详细）-CSDN博客 若是使用虚拟机进行环境模拟，需设置虚拟机网络连接模式为桥接模式。 桥接模式下的虚拟机在网络上相当于是一台独立的主机，可以访问网段内的其他ip地址。 nat模式下的虚拟机相当于主机的一台子设备，只能访问主机本身。</description>
    </item>
    <item>
      <title>First</title>
      <link>https://makisecrise.github.io/post/first/</link>
      <pubDate>Mon, 15 Jul 2024 14:52:34 +0800</pubDate>
      <guid>https://makisecrise.github.io/post/first/</guid>
      <description>IT IS.</description>
    </item>
  </channel>
</rss>
